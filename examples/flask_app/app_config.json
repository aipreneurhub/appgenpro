{
    "_comments": [
            "MUST HAVE ROLES: Client, Full Development Team",
            "MUST HAVE TASKS: RequirementsGathering, SolutionDesign, TechnicalDesign, Implementation"
    ],
    "team": [
        { 
            "role": "Client",
            "goal": "To create a fully-working POC application with high-level requirements.",
            "constraints": "I can provide feedback.",
            "human_input_mode": "ALWAYS"
        },
        { 
            "role": "BusinessAnalyst",
            "goal": "As a Business Analyst, you goal is to analyze business requirements to collect the functional requirements for a given application, and create a requirements document. You must first directly ask the client to provide the details. DO NOT jump straight to writing the document. You MUST ALWAYS ask the client questions about any vague or unclear information and get their replies before writing the requirements document.",
            "constraints": "You should ONLY be working on collecting requirements.",
            "watch_list": ["Client"],
            "actions": ["WriteRequirementsDocument"],
            "react_assistant_instructions": "Analyze the given details to make sure an appropriate requirements document is created for an end-to-end application based on best practices and enterprise standards."
        },
        { 
            "role": "SolutionArchitect",
            "goal": "As a Solution Architect, your goal is to capture non-functional requirements for the given application that will be deployed to cloud. ",
            "constraints": "You should ONLY be working on designing applications. You should NEVER be writing code or implementing the project. ",
            "watch_list": ["BusinessAnalyst"],
            "actions": ["WriteTechnicalDesignDocument"]
        },
        {
            "role": "SeniorEngineer",
            "goal": "As a Senior Engineer, your goal is to make sure that the designed technical solution for the client's request is successfully implemented. This is done in a pair programming paradigm with the Junior Engineers. You are responsible for creating a development backlog based on the technical solution design. You are also responsible for guiding the Junior Engineer to complete the tasks in development backlog. You MUST check the code if it does not work provide feedback back to Junior Engineer. You MUST ensure the quality of the code is good. You MUST finish the entire backlog one by one as instructed and return all the code written when fully done. ",
            "constraints": "You MUST ONLY be mentoring the Junior Engineer. You MUST ONLY be working on applications.",
            "watch_list": ["SolutionArchitect"],
            "actions": ["WriteDevelopmentBacklogDocument"]
        },
        {
            "role": "JuniorEngineer",
            "goal": "As a Junior Engineer, your goal is to complete the tasks in the given product backlog as instructed by the Senior Engineer. You MUST use your assistant to help you write code. You MUST fully implement the code correctly for each task with no empty functions or classes, compliant to language industry standards, and readable. You MUST fix the code if it does not work or if you receive feedback from pair programming. You MUST finish the entire backlog one by one as instructed and return all the code written when fully done. For each task, make sure that you provide feedback about the code to the assistant so that the assistant can write better code. If you have any feedback to fix the code, you MUST instruct the assistant to fix the code before moving onto the next task. Otherwise if the code is perfect, you can instruct them to move on right away to the next task.",
            "constraints": "You MUST ONLY be working on coding the applications.",
            "watch_list": ["SeniorEngineer"],
            "actions": ["WriteCode"]
        }
    ],
    "tasks" : [
        {
            "name": "RequirementsGathering",
            "description": "Gathering Requirements and User Stories",
            "assistant_role_name": "BusinessAnalyst",
            "user_role_name": "Client",
            "task_prompt": "Based on the client's request ({request_prompt}), and the organization standards: {organization_standards}, you must now understand the requirements of the client by asking them a FEW clarifying questions (the less the better). For each question you ask, you must also provide an answer you assume the client would give you and ask them if this answer is correct. You must in the end reply with the completed Requirements Document with all functional, non-functional requirements, and detailed User Stories in Markdown format.",
            "placeholders": {
                "organization_standards": [
                ]
            }
        },
        {
            "name": "SolutionDesign",
            "description": "Designing The Technical Solution",
            "assistant_role_name": "SolutionArchitect",
            "user_role_name": "BusinessAnalyst",
            "task_prompt": "Based on the requirements document ({requirements}), and the organization standards ({organization_standards}), you must now create a solution design document that will be used to develop a solution for the client's request. You must first evaluate what you have created and reply with a solution that covers all functionalities in the requirements. You must in the end reply with the completed Solution Design Document in Markdown format.",
            "placeholders": {
                "organization_standards": [
                    "App Architecture: Domain driven design will be used on a Microservices based modular architecture.",
                    "Frontend UI Building: Frontend applications should be composed of modular and reusable components, promoting consistency and efficiency. Use a component library for common UI elements. Ensure components are loosely coupled and can be easily replaced or updated.",
                    "Modular Frontend Structure: Organize the frontend code into modular components within the 'src' directory. Separate static assets in the 'public' directory. Ensure a consistent coding style and format using tools like ESLint and Prettier. Use the relevant reac design pattern such as MVC as single page application.",
                    "Responsive and Accessible Design: Design for various screen sizes and devices, ensuring responsiveness. Follow accessibility guidelines to make the application usable by as many people as possible. Use semantic HTML and provide alternative texts for media.",
                    "API Gateway: Do not use an API Gateway component for simplicity",
                    "RESTful API Design: RESTful APIs in microservices should be stateless, use HTTP methods explicitly, and be organized around resources. Each microservice should have its own set of endpoints and should communicate with others via API calls. Versioning of APIs is crucial for backward compatibility.",
                    "Authentication: Use JWT stateless authentication",
                    "Database Access: Each microservice should own its database schema and should not share it with other services to ensure loose coupling. Use ORM (Object-Relational Mapping) for database interactions to abstract database engine specifics, allowing flexibility in changing database technologies.",
                    "Error Handling and Logging: Implement consistent error handling across microservices. Use structured logging to provide clear, debuggable output. Ensure logs are centralized for easy monitoring. Include correlation IDs in logs for tracing requests across services.",
                    "State Management and API Integration: Use centralized state management to handle application state more predictably. When integrating with backend APIs, handle asynchronous operations and potential errors gracefully. Cache API responses where appropriate to improve performance.",
                    "Configuration Management: Externalize configuration from the codebase. Use environment variables or centralized configuration services to manage configurations. This approach allows the same application to be deployed in different environments without code changes.",
                    "Scalability and Performance: Design microservices to be stateless to enable horizontal scaling. Monitor performance metrics and use load balancing to distribute traffic. Optimize resource usage to handle varying loads efficiently.",
                    "Dockerization: Each microservice, whether an API or a frontend application, should have its Dockerfile for containerization. Use docker-compose for defining and running multi-container Docker applications, ensuring easy management of services and their dependencies."           
                ]
            }
        },
        {
            "name": "TechnicalDesign",
            "description": "Planning the Development Backlog",
            "assistant_role_name": "SeniorEngineer",
            "user_role_name": "SolutionArchitect",
            "task_prompt": "Based on the design document ({design}), and the organization standards ({organization_standards}), create a detailed development backlog and executable tasks and then translate it into executable pseudocode for each class to be implemented by other engineers so that the client's request can be successfully implemented. You must in the end reply with the completed Development Backlog in Markdown format.",
            "placeholders": {
                "organization_standards": [
                    "API Spec: Create the full API spec before implementation including all tasks defined in the technical design document.",
                    "UI Framework: Use react to implement the UI logic based on related design patterns",
                    "Authenticating Flask APIs: Use JWT based stateless authentication in RESTful APIs. Use extensions like Flask-Login for session management and Flask-HTTPAuth for HTTP authentication. Basic Authentication is used for user login.",
                    "Database Access: Use SQLLite and MangoDB as database backends. Use ORM (Object-Relational Mapping) for database interactions to abstract database engine specifics, allowing flexibility in changing database technologies.",
                    "Error Handling and Logging: Implement consistent error handling across microservices. Use structured logging to provide clear, debuggable output. Ensure logs are centralized for easy monitoring. Include correlation IDs in logs for tracing requests across services.",
                    "State Management and API Integration: Use centralized state management to handle application state more predictably. When integrating with backend APIs, handle asynchronous operations and potential errors gracefully. Cache API responses where appropriate to improve performance.",
                    "Configuration Management: Externalize configuration from the codebase. Use environment variables or centralized configuration services to manage configurations. This approach allows the same application to be deployed in different environments without code changes.",
                    "Dockerization: Each microservice, whether an API or a frontend application, should have its Dockerfile for containerization. Use docker-compose for defining and running multi-container Docker applications, ensuring easy management of services and their dependencies."
                ]
            }

        },
        {
            "name": "Implementation",
            "description": "Implementing The Application",
            "assistant_role_name": "JuniorEngineer",
            "user_role_name": "SeniorEngineer",
            "task_prompt": "Based on the development backlog ({backlog}), and the organization standards ({organization_standards}), write executable code only ensuring adherence to the project's full context. Start starting with the 'main' file and proceeding in dependency order, with no placeholders, no partial implementations, and thorough debugging. You must first evaluate what you have created and reply with working code only.",
            "placeholders": {
                "organization_standards": [
                        "UI Design patterns: Implement the react design patterns.",
                        "React:Follow the official React guidelines for component structure, state management, and hooks. Use JSX properly and keep components small and focused. Apply linting tools like ESLint for code quality.",
                        "Python REST APIs: Adhere to PEP 8 standards for Python code style. Use frameworks like Flask or Django REST framework effectively. Ensure proper error handling and use HTTP status codes correctly.",
                        "Node.js: Use asynchronous programming models properly. Structure your project clearly (e.g., MVC pattern). Apply linting with tools like ESLint.",
                        "Database Access from Python: Use ORM libraries like SQLAlchemy for complex queries and database management. Ensure secure database connections and handle exceptions. Follow best practices for database schema design and query optimization.",
                        "Dockerization Example code: [```\nFROM node:14\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nEXPOSE 3000\nCMD [\"node\", \"server.js\"]\n```\nThis Dockerfile creates a Docker image for a Node.js microservice, installing dependencies and setting the command to start the server.]",
                        "Deployment to Render.com example code: [```yaml\n# render.yaml\nservices:\n- type: web\n  name: flask-react-app\n  env: docker\n  dockerfilePath: ./Dockerfile\n  envVars:\n  - key: ENVIRONMENT\n    value: production\n  - key: DATABASE_URL\n    value: your_database_url\n  healthCheckPath: /\n  regions:\n  - frankfurt\n  autoDeploy: true\n  buildCommand: python -m build\n  startCommand: python run.py\n```]",
                        "SQLAlchemy example code:: [```python\nfrom flask_sqlalchemy import SQLAlchemy\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return f'<User {self.username}>'\n```\n]",
                        "Python Flask API Routes example code: [```python\nfrom flask import Flask, jsonify, request\napp = Flask(__name__)\n\n@app.route('/products', methods=['GET'])\ndef get_products():\n    # Logic to fetch and return products\n    products = [{'id': 1, 'name': 'Product A'}, {'id': 2, 'name': 'Product B'}]\n    return jsonify(products)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\nThis Flask route '/products' is a part of the Product Service in a microservices setup, responsible for managing product data.",
                        "Python packages: Create a python package for each service with a __init__.py file. Write them all in one response since these don't need to be tested. MAKE SURE that each code file you write is in a separate code block (guarded by triple backticks).",
                        "Circular Imports: Avoid circular imports by ensuring that all imports are in the same file."
                ]
            }
        }
    ]
}