{
    "team": [
        { 
            "role": "Client",
            "goal": "To create a fully-working POC application with high-level requirements.",
            "constraints": "I can provide feedback.",
            "human_input_mode": "ALWAYS"
        },
        { 
            "role": "BusinessAnalyst",
            "goal": "As a Business Analyst, you goal is to analyze business requirements to collect the functional requirements for a given web application, and create a requirements document. You must first directly ask the client to provide the details. DO NOT jump straight to writing the document. You MUST ALWAYS ask the client questions about any vague or unclear information and get their replies before writing the requirements document.",
            "constraints": "You should ONLY be working on collecting requirements.",
            "watch_list": ["Client"],
            "actions": ["WriteRequirementsDocument"],
            "react_assistant_instructions": "Analyze the given details to make sure an appropriate requirements document is created for an end-to-end web application based on best practices and enterprise standards."
        },
        { 
            "role": "SolutionArchitect",
            "goal": "As a Solution Architect, your goal is to capture non-functional requirements for the given web application that will be deployed to cloud. ",
            "constraints": "You should ONLY be working on designing web applications. You should NEVER be writing code or implementing the project. ",
            "watch_list": ["BusinessAnalyst"],
            "actions": ["WriteTechnicalDesignDocument"]
        },
        {
            "role": "SeniorEngineer",
            "goal": "As a Senior Engineer, your goal is to make sure that the designed technical solution for the client's request is successfully implemented. This is done in a pair programming paradigm with the Junior Engineers. You are responsible for creating a development backlog based on the technical solution design. You are also responsible for guiding the Junior Engineer to complete the tasks in development backlog. You MUST check the code if it does not work provide feedback back to Junior Engineer. You MUST ensure the quality of the code is good. You MUST finish the entire backlog one by one as instructed and return all the code written when fully done. ",
            "constraints": "You MUST ONLY be mentoring the Junior Engineer. You MUST ONLY be working on web applications.",
            "watch_list": ["SolutionArchitect"],
            "actions": ["WriteDevelopmentBacklogDocument"]
        },
        {
            "role": "JuniorEngineer",
            "goal": "As a Junior Engineer, your goal is to complete the tasks in the given product backlog as instructed by the Senior Engineer. You MUST use your assistant to help you write code. You MUST fully implement the code correctly for each task with no empty functions or classes, compliant to language industry standards, and readable. You MUST fix the code if it does not work or if you receive feedback from pair programming. You MUST finish the entire backlog one by one as instructed and return all the code written when fully done. For each task, make sure that you provide feedback about the code to the assistant so that the assistant can write better code. If you have any feedback to fix the code, you MUST instruct the assistant to fix the code before moving onto the next task. Otherwise if the code is perfect, you can instruct them to move on right away to the next task.",
            "constraints": "You MUST ONLY be working on coding the web applications.",
            "watch_list": ["SeniorEngineer"],
            "actions": ["WriteCode"]
        }
    ],
    "tasks" : [
        {
            "name": "GatherRequirements",
            "description": "Gathering Requirements and User Stories",
            "assistant_role_name": "BusinessAnalyst",
            "user_role_name": "Client",
            "task_prompt": "The Client makes the following request: {request_prompt}. As a business analyst, you must now start by understanding the requirements of the client by asking them a FEW clarifying questions (the less the better). For each question you ask, you must also provide an answer you assume the client would give you and ask them if this answer is correct. You MUST consider the full context, the organization standards: {organization_standards}. Then use the context of the requirements collected from the client and the business analysis to create a Requirements document. You must in the end reply with the completed Requirements Document with all functional, non-functional requirements, and detailed User Stories in Markdown format.",
            "placeholders": {
                "organization_standards": [
                    "Admin Panels: Use the template for admin panel from https://coreui.io/product/free-react-admin-template",
                    "UI: Use the template for UIs from https://react-bootstrap.github.io/"
                ]
            }
        },
        {
            "name": "DesignSolution",
            "description": "Designing The Technical Solution",
            "assistant_role_name": "SolutionArchitect",
            "user_role_name": "BusinessAnalyst",
            "task_prompt": "The Client makes the following request: {request_prompt}. The Business Analyst created a requirements document : {requirements}. As a Solution Architect, use the requirements document to create a technical design document that will be used to develop a solution for the client's request. You MUST consider the full context, the organization standards: {organization_standards}. You must in the end reply with the completed Technical Design Document in Markdown format.",
            "placeholders": {
                "organization_standards": [
                    "Web App Architecture: Domain driven design will be used on an event-driven Microservices based modular architecture.",
                    "Analyze the template code from https://github.com/app-generator/boilerplate-code-flask to define the structure and contents of the web application.",
                    "Frontend UI Building: Frontend applications should be composed of modular and reusable components, promoting consistency and efficiency. Use a component library for common UI elements. Ensure components are loosely coupled and can be easily replaced or updated.",
                    "Modular Frontend Structure: Organize the frontend code into modular components within the 'src' directory. Separate static assets in the 'public' directory. Ensure a consistent coding style and format using tools like ESLint and Prettier. Use the relevant reac design pattern such as MVC as single page application.",
                    "Responsive and Accessible Design: Design for various screen sizes and devices, ensuring responsiveness. Follow web accessibility guidelines to make the application usable by as many people as possible. Use semantic HTML and provide alternative texts for media.",
                    "API Gateway: Do not use an API Gateway component for simplicity",
                    "RESTful API Design: RESTful APIs in microservices should be stateless, use HTTP methods explicitly, and be organized around resources. Each microservice should have its own set of endpoints and should communicate with others via API calls. Versioning of APIs is crucial for backward compatibility.",
                    "Authenticating Flask APIs: Use JWT based stateless authentication in RESTful APIs. Use extensions like Flask-Login for session management and Flask-HTTPAuth for HTTP authentication. Basic Authentication is used for user login.",
                    "Database Access: Each microservice should own its database schema and should not share it with other services to ensure loose coupling. Use ORM (Object-Relational Mapping) for database interactions to abstract database engine specifics, allowing flexibility in changing database technologies.",
                    "Error Handling and Logging: Implement consistent error handling across microservices. Use structured logging to provide clear, debuggable output. Ensure logs are centralized for easy monitoring. Include correlation IDs in logs for tracing requests across services.",
                    "State Management and API Integration: Use centralized state management to handle application state more predictably. When integrating with backend APIs, handle asynchronous operations and potential errors gracefully. Cache API responses where appropriate to improve performance.",
                    "Configuration Management: Externalize configuration from the codebase. Use environment variables or centralized configuration services to manage configurations. This approach allows the same application to be deployed in different environments without code changes.",
                    "Scalability and Performance: Design microservices to be stateless to enable horizontal scaling. Monitor performance metrics and use load balancing to distribute traffic. Optimize resource usage to handle varying loads efficiently.",
                    "Dockerization: Each microservice, whether an API or a frontend application, should have its Dockerfile for containerization. Use docker-compose for defining and running multi-container Docker applications, ensuring easy management of services and their dependencies."           
                ]
            }
        },
        {
            "name": "PlanDevelopment",
            "description": "Planning the Development Backlog",
            "assistant_role_name": "SeniorEngineer",
            "user_role_name": "SolutionArchitect",
            "task_prompt": "The Client makes the following request: {request_prompt}. The Solution Architect created the following design documents: {design}. As a Senior Developer, use the technical design documents to create a detailed development backlog so that the client's request can be successfully implemented by Junior Developers. You MUST consider the full context, the organization standards: {organization_standards}. You must in the end reply with the completed Development Backlog in Markdown format.",
            "placeholders": {
                "organization_standards": [
                    "Analyze the template code from https://github.com/app-generator/boilerplate-code-flask to define the structure and contents of the web application.",
                    "Admin Panels: Define the UI for admins using the template from https://coreui.io/product/free-react-admin-template",
                    "User UI: Define the UI for users using the template from https://react-bootstrap.github.io/",
                    "API Spec: Create the full API spec before implementation",
                    "UI Design patterns: Define the react design patterns",
                    "Authenticating Flask APIs: Use JWT based stateless authentication in RESTful APIs. Use extensions like Flask-Login for session management and Flask-HTTPAuth for HTTP authentication. Basic Authentication is used for user login.",
                    "Database Access: Each microservice should own its database schema and should not share it with other services to ensure loose coupling. Use ORM (Object-Relational Mapping) for database interactions to abstract database engine specifics, allowing flexibility in changing database technologies.",
                    "Error Handling and Logging: Implement consistent error handling across microservices. Use structured logging to provide clear, debuggable output. Ensure logs are centralized for easy monitoring. Include correlation IDs in logs for tracing requests across services.",
                    "State Management and API Integration: Use centralized state management to handle application state more predictably. When integrating with backend APIs, handle asynchronous operations and potential errors gracefully. Cache API responses where appropriate to improve performance.",
                    "Configuration Management: Externalize configuration from the codebase. Use environment variables or centralized configuration services to manage configurations. This approach allows the same application to be deployed in different environments without code changes.",
                    "Dockerization: Each microservice, whether an API or a frontend application, should have its Dockerfile for containerization. Use docker-compose for defining and running multi-container Docker applications, ensuring easy management of services and their dependencies."
                ]
            }

        },
        {
            "name": "ImplementSolution",
            "description": "Implementing The Application",
            "assistant_role_name": "JuniorEngineer",
            "user_role_name": "SeniorEngineer",
            "task_prompt": "The Client makes the following request: {request_prompt}. The Solution Architect created the following design documents: {design}. The Senior Developer created a development backlog from this design: {backlog}. You MUST consider the full context, the organization standards: {organization_standards}. As a Junior Developer specialized in developing cloud native web applications, you will write code to implement ALL of the files in task list in the development backlog ONE BY ONE. You must use the technical design documents and development backlog to plan how to implement each task file and explain your plan for each code file you write with references to these documents. Conditionally, write __init__.py files to mark any directories or packages, write them all in one response since these don't need to be tested. MAKE SURE that each code file you write is in a separate code block (guarded by triple backticks). Use comments in your code to explain what the code does. You will start with the \"main\" file, then go to the ones that are imported by that file, and so on. Please note that the code should be fully functional. Ensure to implement all functions. No placeholders (such as 'pass' in Python). Make sure to finish writing code for all of the files in the task list, run the app from the main function, debug the bugs, before terminating and replying to the Senior Engineer.",
            "placeholders": {
                "organization_standards": [
                        "Application structure: Use the template from https://github.com/app-generator/boilerplate-code-flask to create the code structure, content, and style",
                        "UI Design patterns: Implement the react design patterns",
                        "React:Follow the official React guidelines for component structure, state management, and hooks. Use JSX properly and keep components small and focused. Apply linting tools like ESLint for code quality.",
                        "Python REST APIs: Adhere to PEP 8 standards for Python code style. Use frameworks like Flask or Django REST framework effectively. Ensure proper error handling and use HTTP status codes correctly.",
                        "Node.js: Use asynchronous programming models properly. Structure your project clearly (e.g., MVC pattern). Apply linting with tools like ESLint.",
                        "Database Access from Python: Use ORM libraries like SQLAlchemy for complex queries and database management. Ensure secure database connections and handle exceptions. Follow best practices for database schema design and query optimization.",
                        "Dockerization Example code: [```\nFROM node:14\nWORKDIR /usr/src/app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nEXPOSE 3000\nCMD [\"node\", \"server.js\"]\n```\nThis Dockerfile creates a Docker image for a Node.js microservice, installing dependencies and setting the command to start the server.]",
                        "Deployment to cloud: Deploy dockers on Render.com with example code: [```yaml\n# render.yaml\nservices:\n- type: web\n  name: flask-react-app\n  env: docker\n  dockerfilePath: ./Dockerfile\n  envVars:\n  - key: ENVIRONMENT\n    value: production\n  - key: DATABASE_URL\n    value: your_database_url\n  healthCheckPath: /\n  regions:\n  - frankfurt\n  autoDeploy: true\n  buildCommand: python -m build\n  startCommand: python run.py\n```]",
                        "SQLAlchemy to store the data in the database with example code:: [```python\nfrom flask_sqlalchemy import SQLAlchemy\ndb = SQLAlchemy()\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n    def __repr__(self):\n        return f'<User {self.username}>'\n```\n]",
                        "React Component with Routing example code:: [```javascript\nimport React from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport routes, { renderRoutes } from './routes';\n\nconst App = () => {\n    return (\n        <React.Fragment>\n            <Router basename={BASENAME}>{renderRoutes(routes)}</Router>\n        </React.Fragment>\n    );\n};\n\nexport default App;\n```\n]",
                        "Use Flask Routes with Flask example code: [```python\nfrom flask import Flask, jsonify, request\napp = Flask(__name__)\n\n@app.route('/products', methods=['GET'])\ndef get_products():\n    # Logic to fetch and return products\n    products = [{'id': 1, 'name': 'Product A'}, {'id': 2, 'name': 'Product B'}]\n    return jsonify(products)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\nThis Flask route '/products' is a part of the Product Service in a microservices setup, responsible for managing product data."
                ]
            }
        }


    ]
}